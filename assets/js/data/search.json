[ { "title": "A method for generating a sequence of integers", "url": "/recipes/csharp/2021-11-04-generating-a-sequence-of-integers/", "categories": "recipes, csharp", "tags": "array, linq, csharp, sequence, range", "date": "2021-11-04 16:25:00 -0700", "snippet": "ProblemYou need the sequence of integers [0, n).Solutionusing System.Linq;var sequence = (new int[n]).Select((_, i) =&amp;gt; i);The basic idea is to create an array with the number of elements youneed and map each element to its index (ignoring its value). Theresult is an IEnumerable&amp;lt;int&amp;gt;. If you need theresults in an array or list, you can useToArray&amp;lt;int&amp;gt;() or ToList&amp;lt;int&amp;gt;(),respectively.If you need a different sequence of numbers, you can modify the lambda totransform the index instead of just returning it.This solution requires allocating an array of size n, which takesboth memory and processing time (as each element has to be initializedto its default value), so this solution is best used when n issmall. Keep in mind that as long as the object referenced bysequence is alive, the array is not eligible for garbage collection.How it worksThe expression new int[n] allocations on the heap an array of typeint[] containing n instances of int. The parentheses thatsurround this expression are not needed (see [operator precedence andassociativity][operator-precedence]), but I think they improvereadability a bit.Select&amp;lt;TSource, TResult&amp;gt;() creates an object thattransforms values of type TSource into other values of typeTResult, given a delegate that performs the mapping of a singleelement. Like Python’s map(), Select() doesn’t actually do theiteration and mapping; it just returns an object that will perform themapping as you request the values. You can also compose it with otheroperations like filtering, grouping, etc.We call Select() on the int[], giving it a lambda that returns theindex of each item. The Select() method normally would not beavailable except that we added the using System.Linq statement. Thisbrings in a number of extension methods which extendIEnumerable&amp;lt;T&amp;gt;, and arrays qualify becauseT[] implements IEnumerable&amp;lt;T&amp;gt;. When we call Select&amp;lt;TSource,TResult&amp;gt;() on an IEnumerable&amp;lt;T&amp;gt;, TSource gets set to T which,in our case, is int. TResult is determined by the type of thereturn value of the delegate that is passed into Select().Select() has an overload which takes adelegate that receives both the current value and the index of thatvalue within the IEnumerable&amp;lt;T&amp;gt;. The lambda we are passing in, (_,i) =&amp;gt; i, does nothing with the value and just returns its 2ndargument, the index, which means the return value of the delegate thatgets created from this lambda must have the same type as i. Thismeans TResult in Select&amp;lt;TSource, TResult&amp;gt;() must be int sincethe Select() overload requires the 2ndparameter to be int. The compiler converts the lambda (_, i) =&amp;gt; iinto a delegate of type Func&amp;lt;int, int, int&amp;gt; and alsoinstantiates the overload just mentioned, namely Select&amp;lt;int,int&amp;gt;(this IEnumerable&amp;lt;int&amp;gt; source, Func&amp;lt;int, int, int&amp;gt; selector).The return value of Select&amp;lt;int, int&amp;gt;() is an IEnumerable&amp;lt;int&amp;gt;which you can then iterate over, convert to an array, etc. As eachvalue is requested, its index is returned instead of the value,thereby returning the sequence [0, n)." } ]
